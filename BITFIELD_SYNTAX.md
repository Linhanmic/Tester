# 位域函数语法说明

## 概述

位域函数语法允许您将同一个CAN报文的多个信号位封装成一个函数，支持不同的参数类型（数值、枚举）和缩放因子。这样可以更直观地设置CAN报文的内容，而不需要手动计算每个字节的值。

## 语法定义

### 1. 枚举定义

枚举定义用于定义一组命名的常量值。

**语法格式：**
```
tenum 枚举名 数值1=名称1, 数值2=名称2, ...
```

**示例：**
```
// 定义车速单位枚举
tenum 车速单位枚举 0=km/h, 1=mph, 2=m/s

// 定义档位枚举
tenum 档位枚举 0=P档, 1=R档, 2=N档, 3=D档, 4=S档
```

### 2. 位域函数定义

位域函数定义将多个参数映射到CAN报文的不同位域。

**语法格式：**
```
tbitfield 函数名 参数1="显示名1", 参数2="显示名2", ...: CAN_ID, 位域1="参数1"/缩放因子, 位域2="参数2", ...
```

**参数说明：**
- `函数名`：位域函数的名称，用于调用时引用
- `参数名="显示名"`：定义函数的参数，参数名用于调用时指定值，显示名用于文档说明
- `CAN_ID`：CAN报文ID（可以省略0x前缀，默认为十六进制）
- `位域="参数名"/缩放因子`：将参数映射到CAN报文的位域
  - 位域格式：`字节.位-字节.位`（字节从1开始，位从0-7）
  - 缩放因子：可选，用于数值类型参数的缩放（例如：`/100`表示参数值乘以100）

**示例：**
```
// 定义车速函数
// 参数：车速值（数值，缩放100倍），车速单位（枚举）
// CAN ID: 0x144
// 位域映射：
//   - 字节1.0到字节2.7 -> 车速值（乘以100）
//   - 字节3.0到字节3.1 -> 车速单位
tbitfield 车速 车速值="车速值", 车速单位="车速单位": 144, 1.0-2.7="车速值"/100, 3.0-3.1="车速单位"

// 定义档位信息函数
// 参数：当前档位（枚举），发动机转速（数值，缩放10倍）
// CAN ID: 0x260
tbitfield 档位信息 当前档位="档位", 发动机转速="转速": 260, 1.0-1.2="档位", 2.0-3.7="转速"/10
```

### 3. 位域函数调用

在测试用例中调用位域函数，传入参数值。

**语法格式：**
```
函数名 参数1=值1, 参数2=值2, ...
```

**参数值类型：**
- **数值类型**：直接使用数字（整数或浮点数）
- **枚举类型**：使用枚举中定义的名称

**示例：**
```
// 发送车速100km/h
车速 车速值=100, 车速单位=km/h

// 发送车速60mph
车速 车速值=60, 车速单位=mph

// D档，转速2500rpm
档位信息 当前档位=D档, 发动机转速=2500
```

## 完整示例

```
// 1. 定义枚举
tenum 车速单位枚举 0=km/h, 1=mph, 2=m/s
tenum 档位枚举 0=P档, 1=R档, 2=N档, 3=D档, 4=S档

// 2. 定义位域函数
tbitfield 车速 车速值="车速值", 车速单位="车速单位": 144, 1.0-2.7="车速值"/100, 3.0-3.1="车速单位"
tbitfield 档位信息 当前档位="档位", 发动机转速="转速": 260, 1.0-1.2="档位", 2.0-3.7="转速"/10

// 3. 设备配置
tset
  tcaninit 4, 0, 0, 500
tend

// 4. 测试用例
ttitle=位域函数测试

  1 tstart=车速和档位测试
    // 设置车速80km/h
    车速 车速值=80, 车速单位=km/h

    // 设置D档，转速3000rpm
    档位信息 当前档位=D档, 发动机转速=3000

    tdelay 500

    // 加速到120km/h
    车速 车速值=120, 车速单位=km/h

    // 切换到S档，转速上升到4500rpm
    档位信息 当前档位=S档, 发动机转速=4500
  tend

ttitle-end
```

## 工作原理

### 位域编码

位域函数会根据定义自动生成CAN报文数据：

1. **初始化8字节数据**：所有字节初始化为0
2. **处理每个参数**：
   - 对于数值类型：直接使用数值
   - 对于枚举类型：从枚举定义中查找对应的数值
3. **应用缩放因子**：如果定义了缩放因子，将参数值乘以缩放因子
4. **写入位域**：使用Intel字节序（低位字节在前）将值写入指定的位域
5. **发送CAN报文**：生成tcans命令并发送

### 示例计算

以`车速 车速值=100, 车速单位=km/h`为例：

1. 车速值=100，缩放因子=100，实际值=100×100=10000（0x2710）
2. 车速单位=km/h，对应枚举值=0
3. 位域映射：
   - 1.0-2.7（16位）：10000（0x2710）
   - 3.0-3.1（2位）：0
4. 生成的CAN数据（Intel字节序）：
   - 字节1：0x10
   - 字节2：0x27
   - 字节3：0x00
   - 其他字节：0x00
5. 最终CAN报文：`ID=0x144, Data=10 27 00 00 00 00 00 00`

## 注意事项

1. **字节和位索引**：
   - 字节索引从1开始（1表示第一个字节）
   - 位索引从0到7（0是最低位，7是最高位）

2. **字节序**：
   - 使用Intel字节序（小端序），低位字节在前

3. **缩放因子**：
   - 缩放因子是可选的，只用于数值类型参数
   - 语法：`/数值`，例如`/100`表示参数值乘以100

4. **枚举值查找**：
   - 枚举类型参数会自动从所有定义的枚举中查找
   - 如果找不到枚举值，会报错

5. **参数验证**：
   - 调用时必须提供函数定义中的所有参数
   - 参数名必须与定义中的参数名完全匹配

## 优势

相比手动编写tcans命令，位域函数语法有以下优势：

1. **可读性**：参数名称清晰，易于理解
2. **可维护性**：修改信号定义时只需修改函数定义
3. **类型安全**：支持枚举类型，避免使用错误的数值
4. **自动计算**：自动处理位域编码和缩放因子，减少人工计算错误
5. **复用性**：一次定义，多次调用

## 脚本转换功能

### 功能说明

为了兼容旧版软件或便于调试，Tester提供了脚本转换功能，可以将包含位域函数语法的脚本转换为原始的tcans指令脚本。

### 使用方法

1. **通过命令面板**：
   - 打开包含位域函数语法的.tester文件
   - 按下 `Ctrl+Shift+P`（Windows/Linux）或 `Cmd+Shift+P`（Mac）打开命令面板
   - 输入并选择 `Tester: 转换为原始指令脚本`
   - 转换后的脚本将在新窗口中显示

2. **直接执行**：
   - 当前版本的Tester扩展可以直接执行包含位域函数语法的脚本
   - 不需要手动转换即可运行测试

### 转换结果示例

**源脚本（位域函数语法）：**
```
tenum 车速单位 0=km/h, 1=mph
tbitfield 车速 车速值="车速", 车速单位="单位": 144, 1.0-2.7="车速"/100, 3.0-3.1="单位"

ttitle=测试
  1 tstart=测试用例
    车速 车速值=100, 车速单位=km/h
    tdelay 100
  tend
ttitle-end
```

**转换后的脚本（原始指令）：**
```
// ================================================================
// 自动生成的原始指令脚本
// 由位域函数语法转换而来
// 生成时间: 2025/11/27 16:06:21
// ================================================================

// ========== 枚举定义 ==========
// tenum 车速单位
//   0=km/h, 1=mph

// ========== 位域函数定义 ==========
// tbitfield 车速
//   CAN ID: 0x144
//   参数: 车速值="车速", 车速单位="单位"

ttitle=测试

  1 tstart=测试用例
    // 车速 车速值=100, 车速单位=km/h
    tcans 0x144, 10 27 00 00 00 00 00 00, 0, 1
    tdelay 100
  tend

ttitle-end
```

### 转换功能特点

1. **保留原始调用信息**：每个转换后的tcans命令前都会添加注释，说明原始的位域函数调用
2. **文档化**：在脚本开头添加枚举和位域函数定义的注释，便于理解
3. **时间戳**：记录转换时间，便于追踪版本
4. **配置保留**：设备配置块保持不变
5. **可执行**：转换后的脚本可以在旧版Tester中直接运行

### 适用场景

- **兼容性**：在不支持位域函数语法的旧版Tester中运行测试
- **调试**：查看位域函数实际生成的CAN报文数据
- **学习**：理解位域编码的具体过程
- **文档**：生成可以脱离位域函数定义独立运行的脚本
